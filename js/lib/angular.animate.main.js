/*
 AngularJS v1.7.8
 (c) 2010-2018 Google, Inc. http://angularjs.org
 Licença: MIT
*/
(function (Y, z) {'use strict'; function Fa (a, b, c) {if (! a) lança Pa ("areq", b || "?", c || "obrigatório"); retorna uma função} Ga (a, b) {if (! a &&! b) return ""; if (! a) retorna b; if (! b) retorna a; Z (a) && (a = a.join ( "")); Z (b) && (b = b.join ("")); retorne a + "" + b} função Qa (a) {var b = {}; a && (a.to || a. a partir de) && (b.to = a.to, b.from = a.from); retornar b} função $ (a, b, c) {var d = ""; a = Z (a)? a: a && G (a) && a.length? a.split (/ \ s + /): []; s (a, function (a, k) {a && 0 <a.length && (d + = 0 <k? "": "", d + = c? b + a: a + b)}); return d} função Ha (a) {if (uma instância de A) switch (a.length) {case 0: return a;
case 1: if (1 === a [0] .nodeType) retorna a; break; padrão: retorna A (va (a))} if (1 === a.nodeType) retorna A (a)} função va (a) {if (! a [0]) retorna a; for (var b = 0; b <comprimento a; b ++) {var c = a [b]; if (1 === c.nodeType) return c}} função Ra (a, b, c) {s (b, função (b) {a.addClass (b, c)})} função Sa (a, b, c) {s (b, função (b ) {a.removeClass (b, c)})} função aa (a) {função de retorno (b, c) {c.addClass && (Ra (a, b, c.addClass), c.addClass = null); c .removeClass && (Sa (a, b, c.removeClass), c.removeClass = null)}} função pa (a) {a = a || {}; se (! a. $$ preparado) {var b = a .domOperation ||
N; a.domOperation = function () {a. $$ domOperationFired =! 0; b (); b = N}; a. $$ preparado =! 0} retorna a} função ha (a, b) {Ia ( a, b); Ja (a, b)} função Ia (a, b) {b.from && (a.css (b.from), b.from = null)} função Ja (a, b) {b. para && (a.css (b.to), b.to = nulo)} função T (a, b, c) {var d = b.opções || {}; c = c.opções || {}; var f = (d.addClass || "") + "" + (c.addClass || ""), k = (d.removeClass || "") + "" + (c.removeClass || ""); a = Ta (a.attr ("classe"), f, k); c.preparationClasses && (d.preparationClasses = ba (c.preparationClasses, d.preparationClasses), exclua c.preparationClasses);
f = d.domOperation! == N? d.domOperation: null; wa (d, c); f && (d.domOperation = f); d.addClass = a.addClass? a.addClass: null; d.removeClass = a.removeClass? a.removeClass: null; b.addClass = d.addClass; b.removeClass = d.removeClass; return d} função Ta (a, b, c) {função d (a) {G (a) && (a = a.split ("")); var c = {}; s (a, função (a) {a.length && (c [a] =! 0)}); return c} var f = {} ; a = d (a); b = d (b); s (b, função (a, c) {f [c] = 1}); c = d (c); s (c, função (a, c) {f [c] = 1 === f [c]? null: -1}); var k = {addClass: "", removeClass: ""}; s (f, função (c, b) { var d, f; 1 === c? (d = "addClass",
f =! a [b] || a [b + "- remove"]): - 1 === c && (d = "removeClass", f = a [b] || a [b + "- add"]); f && (k [d] .length && (k [d] + = ""), k [d] + = b)}); retornar k} função K (a) {retornar uma instância de A? a [0]: a } função Ua (a, b, c, d) {a = ""; c && (a = $ (c, "ng -" ,! 0)); d.addClass && (a = ba (a, $ (d. addClass, "- add"))); d.removeClass && (a = ba (a, $ (d.removeClass, "- remove"))); a.length && (d.preparationClasses = a, b.addClass (a) )} função xa (a, b) {var c = b? "pausada": "", d = ca + "PlayState"; ma (a, [d, c]); retornar [d, c]} função ma ( a, b) {a.style [b [0]] = b [1]} função ba (a, b) {retorna a? b? a + "" +
b: a: b} função Ka (a, b, c) {var d = Object.criar (nulo), f = a.getComputedStyle (b) || {}; s (c, função (a, c) { var b = f [a]; se (b) {var L = b.charAt (0); if ("-" === L || "+" === L || 0 <= L) b = Va (b); 0 === b && (b = nulo); d [c] = b}}); return d} função Va (a) {var b = 0; a = a.split (/ \ s * , \ s * /); s (a, function (a) {"s" === a.charAt (a.length-1) && (a = a.substring (0, a.length-1)); a = parseFloat (a) || 0; b = b? Math.max (a, b): a}); return b} função ya (a) {return 0 === a || null! = a} função La (a, b) {var c = M, d = a + "s"; b? C + = "Duração": d + = "tudo linear"; retorna [c, d]} função Ma (a, b, c) {s (c,
função (c) {a [c] = za (a [c])? a [c]: b.style.getPropertyValue (c)})} var M, Aa, ca, Ba; void 0 === Y. ontransitionend && void 0! == Y.onwebkittransitionend? (M = "WebkitTransition", Aa = "webkitTransitionEnd transiçãoend") :( M = "transição", Aa = "transiçãoend"); void 0 === Y.onanimationend && void 0! == Y.onwebkitanimationend? (Ca = "WebkitAnimation", Ba = "webkitAnimationEnd animationend") :( ca = "animação", Ba = "animationend"); var qa = ca + "Atraso", Ca = ca + "Duração", na = M + "Atraso", Na = M + "Duração", Pa = z. $$ minErr ("ng"), ra = {blockTransitions: function (a,
b) {var c = b? "-" + b + "s": ""; ma (a, [na, c]); return [na, c]}}, Wa = {transiçãoDuração: Na, transiçãoDelay: na , transiçãoPropriedade: M + "Propriedade", animationDuration: Ca, animationDelay: qa, animationIterationCount: ca + "IterationCount"}, Xa = {transiçãoDuração: Na, transiçãoDelay: na, animationDuração: Ca, animationDelay: qa}, Z, za, sa, Ea, ta, G, R, A, N; z.module ("ngAnimate", [], função () {N = z.noop; Da = z.copy; wa = z.extend ; A = z.element; s = z.forEach; Z = z.isArray; G = z.isString; ta = z.isObject; R = z.isUndefined; za = z.isDefined; Ea = z.isFunction;
sa = z.isElement}). info ({angularVersion: "1.7.8"}). directiva ("ngAnimateSwap", ["$ animate", função (a) {return {strict: "A", transclude: "elemento ", terminal:! 0, prioridade: 550, link: function (b, c, d, f, k) {var e, Q; b. $ watchCollection (d.ngAnimateSwap || d [" for "], function ( b) {e && a.leave (e); Q && (Q. $ destroy (), Q = null); (b || 0 === b) && k (função (b, d) {e = b; Q = d ; a.enter (b, null, c)})})}}]]). directiva ("ngAnimateChildren", ["$ interpolate", function (a) {return {link: function (b, c, d) {function f (a) {c.data ("$$ ngAnimateChildren", "on" === a || "true" ===
a)} var k = d.ngAnimateChildren; G (k) && 0 === k.length? c.data ("$$ ngAnimateChildren",! 0) :( f (a (k) (b)), d. $ observe ("ngAnimateChildren", f))}}}]). factory ("$$ rAFScheduler", ["$$ rAF", função (a) {função b (a) {d = d.concat (a) ; c ()} função c () {if (comprimento d) {for (var b = d.shift (), e = 0; e <comprimento comprimento; e ++) b [e] (); f || a (function () {f || c ()})}} var d, f; d = b.queue = []; b.waitUntilQuiet = função (b) {f && f (); f = a (function () {f = null; b (); c ()})}; return b}]). provider ("$$ animateQueue", ["$ animateProvider", função (a) {function b (a) {return {addClass : a.addClass,
removeClass: a.removeClass, de: a.from, para: a.to}} função c (a) {if (! a) retorna nulo; a = a.split (""); var b = Object.create ( nulo); s (a, função (a) {b [a] =! 0}); return b} função d (a, b) {if (a && b) {var d = c (b); return a.split ("") .algumas (função (a) {retornar d [a]})}} função f (a, b, c) {retornar e [a] .algumas (função (a) {retornar a (b, c )})} função k (a, b) {var c = 0 <(a.addClass || ""). length, d = 0 <(a.removeClass || ""). length; return b? c && d: c || d} var e = this.rules = {skip: [], cancel::], join: []}; e.join.push (function (a, b) {return! a.estrutural && k (a) });
e.skip.push (função (a, b) {return! a.estrutural &&! k (a)}); e.skip.push (função (a, b) {return "leave" === b.event && a. estrutural}); e.skip.push (função (a, b) {return b.estrutural && 2 === b.state &&! a.estrutural}); e.cancel.push (função (a, b) {return b. estrutural && a.estrutural}); e.cancel.push (função (a, b) {return 2 === b.state && a.estrutural}); e.cancel.push (função (a, b) {if (b.estrutural ) retorna! 1; var c = a.addClass, f = a.removeClass, k = b.addClass, e = b.removeClass; retorna R (c) && R (f) || R (k) && R (e)? ! 1: d (c, e) || d (f, k)}); isto. $ Get = ["$$ rAF",
"$ rootScope", "$ rootElement", "$ document", "$$ Map", "$$ animation", "$$ AnimateRunner", "$ templateRequest", "$$ jqLite", "$$ forceReflow", "$$ isDocumentHidden", função (c, d, e, C, U, oa, H, u, t, I, da) {function ia (a) {O.delete (a.target)} function v () {var a =! 1; função de retorno (b) {a? b (): d. $$ postDigest (função () {a =! 0; b ()})}} função ua (a, b, c) {var g = [], l = m [c]; l && s (l, função (l) {Oa.call (l.node, b)? g.push (l.callback): "leave" === c && Oa .call (l.node, a) && g.push (l.callback)}); return g} function h (a, b, c) {var l = va (b); return a.filter (function (a) {return! (a.node ===
l && (! c || a.callback === c))})} função q (a, J, w) {função e (a, b, l, g) {u (função () {var a = ua (ia, m, b); a.length? c (function () {s (a, function (a) {a (h, l, g)}); "fechar"! == l || m.parentNode || D.off (m)}): "fechar"! == l || m.parentNode || D.off (m)}); a.progress (b, l, g)} função I (a) {var b = h, c = n; c.preparationClasses && (b.removeClass (c.preparationClasses), c.preparationClasses = null); c.activeClasses && (b.removeClass (c.activeClasses), c.activeClasses = null); W (h, n); ha (h, n); n.domOperation (); q.complete (! A)} var n = Da (w), h = Ha (a), m = K (h), ia = m &&
m.parentNode, n = pa (n), q = novo H, u = v (); Z (n.addClass) && (n.addClass = n.addClass.join ("")); n.addClass &&! G (n.addClass) && (n.addClass = null); Z (n.removeClass) && (n.removeClass = n.removeClass.join ("")); n.removeClass &&! G (n.removeClass) && (n .removeClass = null); n.from &&! ta (n.from) && (n.from = null); n.to &&! ta (n.to) && (n.to = null); if (! (B &&m && fa ( m, J, w) && Ya (m, n))) retornam I (), q; var x = 0 <= ["entrar", "mover", "sair"]. indexOf (J), r = da ( ), P = r || O.get (m); w =! P &&.get (m) || {}; var p = !! w.state; P || p && 1 === w.state || ( P =! E (m, ia, J)); se (P) retornar r &&
e (q, J, "iniciar", b (n)), I (), r && e (q, J, "fechar", b (n)), q; x && F (m); r = {estrutural: x, elemento: h, evento: J, addClass: n.addClass, removeClass: n.removeClass, close: I, opções: n, runner: q}; if (p) {if (f ("skip", r, w) ) {if (2 === w.state) retorna I (), q; T (h, w, r); retorna w.runner} if (f ("cancel", r, w)) if (2 = == w.state) w.runner.end (); else if (w.estrutural) w.close (); else retornará T (h, w, r), w.runner; else if (f ("join" , r, w)) if (2 === w.state) T (h, r, {}); else return Ua (t, h, x? J: null, n), J = r.event = w .event, n = T (h, w, r), w.runner} else T (h, r, {}); (p = r.estrutural) ||
(p = "animate" === r.event && 0 <Object.keys (r.options.to || {}). length || k (r)); se (! p) retornar I (), g (m ), q; var C = (w.counter || 0) +1; r.counter = C; l (m, 1, r); d. $$ postDigest (função () {h = Ha (a)); var c = y.get (m), d =! c, c = c || {}, t = 0 <(h.parent () || []). length && ("animate" === c.event || c.estrutural || k (c)); if (d || c.counter! == C ||! t) {d && (W (h, n), ha (h, n)); if ( d || x && c.event! == J) n.domOperation (), q.end (); t || g (m)} mais J =! c.estrutural && k (c,! 0)? "setClass": c .event, l (m, 2), c = oa (h, J, c.options), q.setHost (c), e (q, J, "início", b (n)), c.done ( função (a) {I (! a);
(a = y.get (m)) && a.counter === C && g (m); e (q, J, "fechar", b (n))})}); retornar q} função F (a) { a = a.querySelectorAll ("[data-ng-animate]"); s (a, função (a) {var b = parseInt (a.getAttribute ("data-ng-animate"), 10), c = y .get (a); if (c) switch (b) {case 2: c.runner.end (); case 1: y.delete (a)}})} function g (a) {a.removeAttribute (" data-ng-animate "); y.delete (a)} função E (a, b, c) {c = C [0] .body; var l = K (e), g = a === c | | "HTML" === a.nodeName, d = a === l, t =! 1, m = O.get (a), h; para ((a = A.data (a, "$ ngAnimatePin") )) && (b = K (a)); b;) {d || (d = b === l); if (1! == b.nodeType) break;
a = y.get (b) || {}; if (! t) {var f = O.get (b); if (! 0 === f &&! 1! == m) {m =! 0; break} else! 1 === f && (m =! 1); t = a.estrutural} if (R (h) ||! 0 === h) a = A.data (b, "$$ ngAnimateChildren" ), za (a) && (h = a); if (t &&! 1 === h) break; g || (g = b === c); if (g && d) break; if (! d && (a = A.data (b, "$ ngAnimatePin"))) {b = K (a); continue} b = b.parentNode} retorno (! T || h) &&! 0! == m && d && g} função l (a , b, c) {c = c || {}; c.state = b; a.setAttribute ("animador de dados em ng", b); c = (b = y.get (a))? wa ( b, c): c; y.set (a, c)} var y = novo U, O = novo U, B = nulo, P = d. $ watch (function () {return 0 === u.totalPendingRequests }, função (a) {a &&
(P (), d. $$ postDigest (função () {d. $$ postDigest (função () {null === B && (B =! 0)})}))}), m = Object.create ( nulo); U = a.customFilter (); var la = a.classNameFilter (); I = função () {return! 0}; var fa = U || I, Ya = la? função (a, b) { var c = [a.getAttribute ("classe"), b.addClass, b.removeClass] .join (""); retorna la.test (c)}: I, W = aa (t), Oa = Y. Node.prototype.contains || function (a) {return this === a || !! (this.compareDocumentPosition (a) & 16)}, D = {on: function (a, b, c) {var l = va (b); m [a] = m [a] || []; m [a] .push ({nó: l, retorno de chamada: c}); A (b) .on ("$ destroy", função () {y.get (l) ||
D.off (a, b, c)})}, off: function (a, b, c) {if (1! == argumentos.length || G (argumentos [0])) {var l = m [ a]; l && (m [a] = 1 === argumentos.length? null: h (l, b, c))} else for (l em b = argumentos [0], m) m [l] = h (m [l], b)}, pin: function (a, b) {Fa (sa (a), "elemento", "não é um elemento"); Fa (sa (b), "parentElement", "not um elemento "); a.data (" $ ngAnimatePin ", b)}, push: function (a, b, c, l) {c = c || {}; c.domOperation = l; return q (a, b, c)}, enabled: function (a, b) {var c = argument.length; if (0 === c) b = !! B; caso contrário, se (sa (a)) {var l = K ( a); if (1 === c) b =! O.get (l); senão {if (! O.has (l)) A (a) .on ("$ destroy",
ia); O.set (l,! b)}} else b = B = !! a; retorne b}}; retorne D}]}]). provider ("$$ animateCache", function () {var a = 0, b = Object.create (null); this. $ Get = [function () {return {cacheKey: function (b, d, f, k) {var e = b.parentNode; b = [e. $ $ ngAnimateParentKey || (e. $$ ngAnimateParentKey = ++ a), d, b.getAttribute ("classe")]; f && b.push (f); k && b.push (k); return b.join ("") }, containsCachedAnimationWithoutDuration: function (a) {return (a = b [a]) &&! a.isValid ||! 1}, flush: function () {b = Object.create (null)}, count: function (a ) {return (a = b [a])? a.total controlado},get:function(a){return(a=
b [a]) && a.value}, coloque: function (a, d, f) {b [a]? (b [a] .total ++, b [a] .valor = d): b [a] = { total: 1, valor: d, isValid: f}}}}]}). provider ("$$ animation", ["$ animateProvider", função (a) {var b = this.drivers = []; this. $ get = ["$$ jqLite", "$ rootScope", "$ injector", "$$ AnimateRunner", "$$ Map", "$$ rAFScheduler", "$$ animateCache", função (a, d, f, k, e, Q, L) {função x (a) {função b (a) {se (a.processed) retorna a; a.processed =! 0; var d = a.domNode, t = d. parenteNode; f.set (d, a); for (var h; t;) {if (h = f.get (t)) {h.processed || (h = b (h)); break} t = t.parentNode} (h ||
c) .children.push (a); retorna a} var c = {filhos: []}, d, f = novo e; para (d = 0; d <comprimento.de; d ++) {var da = a [ d]; f.set (da.domNode, a [d] = {domNode: da.domNode, elemento: da.element, fn: da.fn, filhos: []})} para (d = 0; d < a.length; d ++) b (a [d]); função de retorno (a) {var b = [], c = [], d; for (d = 0; d <a.children.length; d ++) c .push (a.children [d]); a = c.length; var t = 0, f = []; for (d = 0; d <c.length; d ++) {var g = c [d]; 0> = a && (a = t, t = 0, b.push (f), f = []); f.push (g); g.children.forEach (function (a) {t ++; c.push ( a)}); a -} comprimento f && b.push (f); retorno b} (c)} var C = [], U = aa (a); função de retorno (e,
H, u) {função t (a) {a = a.hasAttribute ("ng-animate-ref")? [A]: a.querySelectorAll ("[ng-animate-ref]"); var b = [] ; s (a, function (a) {var c = a.getAttribute ("ng-animate-ref"); c && c.length && b.push (a)}); return b} função I (a) {var b = [ ], c = {}; s (a, função (a, d) {var l = K (a.element), g = 0 <= ["enter", "move"]. indexOf (a.event), l = a.estrutural? t (l): []; se (comprimento.l) {var f = g? "a": "from"; s (l, função (a) {var b = a.getAttribute ( "ng-animate-ref"); c [b] = c [b] || {}; c [b] [f] = {animationID: d, elemento: A (a)}})} else b.push (a)}); var d = {}, g = {}; s (c, função (c,
t) {var f = c.from, e = c.to; if (f && e) {var h = a [f.animationID], k = a [e.animationID], E = f.animationID.toString (); if (! g [E]) {var I = g [E] = {estrutural:! 0, beforeStart: function () {h.beforeStart (); k.beforeStart ()}, close: function () {h. close (); k.close ()}, classes: da (h.classes, k.classes), de: h, para: k, âncoras: []}; I.classes.length? b.push (I) : (b.push (h), b.push (k))} g [E] .anchors.push ({out: f.element, "in": e.element})} else f = f? f. ID da animação: e.animationID, e = f.toString (), d [e] || (d [e] =! 0, b.push (a [f]))}); return b} function da (a, b) {a = a.split ("");
b = b.split (""); para (var c = [], d = 0; d <comprimento.a; d ++) {var g = a [d]; if ("ng -"! == g. substring (0,3)) para (var t = 0; t <comprimento b; t ++) if (g === b [t]) {c.push (g); break}} retornar c.join (" ")} função ia (a) {for (var c = b.length-1; 0 <= c; c -) {var d = f.get (b [c]) (a); if (d) retornar d}} função v (a, b) {função c (a) {(a = a.data ("$$ animationRunner"))) && a.setHost (b)} a.from && a.to? (c (a. from.element), c (a.element)): c (a.element)} função ua () {var a = e.data ("$$ animationRunner") ;! a || "leave" == = H && u. $$ domOperationFired || a.end ()} função h (b) {e.off ("$ destroy",
ua); e.removeData ("$$ animationRunner"); U (e, u); ha (e, u); u.domOperation (); E && a.removeClass (e, E); F.complete (! b) } u = pa (u); var q = 0 <= ["entrar", "mover", "sair"]. indexOf (H), F = novo k ({end: function () {h ()}, cancel: function () {h (! 0)}}); if (! b.length) retorna h (), F; var g = Ga (e.attr ("classe"), Ga (u.addClass, u .removeClass)), E = u.tempClasses; E && (g + = "" + E, u.tempClasses = nulo); q && e.data ("$$ animatePrepareClasses", "ng -" + H + "- prepare"); e .data ("$$ animationRunner", F); C.push ({elemento: e, classes: g, evento: H, estrutural: q, opções: u, beforeStart: function () {E =
(E? E + "": "") + "ng-animate"; a.addClass (e, E); var b = e.data ("$$ animatePrepareClasses"); b && a.removeClass (e, b)}, fechar: h}); e.on ("$ destroy", ua); if (1 <C.length) retornar F; d. $$ postDigest (function () {var b = []; s (C, function (a) {a.element.data ("$$ animationRunner")? b.push (a): a.close ()}); C.length = 0; var d = I (b), g = [] ; s (d, função (a) {var b = a.from? a.from.element: a.element, c = u.addClass, d = L.cacheKey (b [0], a.event, (c ? c + "": "") + "ng-animate", u.removeClass); g.push ({elemento: b, domNode: K (b), fn: function () {var b, c = a.close ; if (L.containsCachedAnimationWithoutDuration (d)) c ();
else {a.beforeStart (); if ((a.anchors? a.from.element || a.to.element: a.element) .data ("$$ animationRunner")) {var g = ia (a) ; g && (b = g.start)} b? (b = b (), b.done (função (a) {c (! a)}), v (a, b)): c ()}}} )}); para (var d = x (g), t = 0; t <comprimento d; t ++) for (var f = d [t], e = 0; e <comprimento f; e ++) {var h = f [e], k = elemento h; d [t] [e] = h.fn; 0 === t? k.removeData ("$$ animatePrepareClasses") :( h = k.data (" $$ animatePrepareClasses ")) && a.addClass (k, h)} Q (d)}); retorne F}}]}]). provider (" $ animateCss ", [" $ animateProvider ", function (a) {this . $ get = ["$ window", "$$ jqLite", "$$ AnimateRunner",
"$ timeout", "$$ animateCache", "$$ forceReflow", "$ sniffer", "$$ rAFScheduler", "$$ animateQueue", função (a, c, d, f, k, e, Q, L, x) {função C (d, f, e, x) {var v, s = "cambalear -" + e; 0 <k.count (e) && (v = k.get (s), v | | (f = $ (f, "- escalonar"), c.addClass (d, f), v = Ka (a, d, x), v.animationDuration = Math.max (v.animationDuration, 0), v .transitionDuration = Math.max (v.transitionDuration, 0), c.removeClass (d, f), k.put (s, v,! 0))); return v || {}} função U (a) { u.push (a); L.waitUntilQuiet (function () {k.flush (); for (var a = e (), b = 0; b <comprimento do usuário; b ++) u [b] (a); comprimento = 0})}
função z (c, d, f, e) {d = k.get (f); d || (d = Ka (a, c, Wa), "infinito" === d.animationIterationCount && (d.animationIterationCount = 1)); k.put (f, d, e || 0 <d.transitionDuration || 0 <d.animationDuration); c = d; f = c.animationDelay; e = c.transitionDelay; c.maxDelay = f && e ? Math.max (f, e): f || e; c.maxDuration = Math.max (c.animationDuration * c.animationIterationCount, c.transitionDuration); retorno c} var H = aa (c), u = [ ]; função de retorno (a, b) {função e () {v ()} função L () {v (! 0)} função v (b) {se (! (P | | la && m)) {P =! 0; m =! 1; V &&! G. $$ skipPreparationClasses &&
c.removeClass (a, V); ba && c.removeClass (a, ba); xa (l,! 1); ra.blockTransitions (l,! 1); s (y, função (a) {l.style [a [0]] = ""}); H (a, g); ha (a, g); Object.keys (E) .length && s (E, função (a, b) {a? L.style.setProperty ( b, a): l.style.removeProperty (b)}); if (g.onDone) g.onDone (); w && w.length && a.off (w.join ("")), q); var d = a. data ("$$ animateCss"); d && (f.cancel (d [0] .timer), a.removeData ("$$ animateCss")); fa && fa.complete (! b)}} função u (a) { p.blockTransition && ra.blockTransitions (l, a); p.blockKeyframeAnimation && xa (l, !! a)} função h () {fa = new d ({end: e,
cancel: L}); U (N); v (); return {$$ willAnimate:! 1, start: function () {return fa}, end: e}} function q (a) {a.stopPropagation () ; var b = a.originalEvent || a; b.target === l && (a = b. $ manualTimeStamp || Date.now (), b = parseFloat (b.elapsedTime.toFixed (3)), Math.max (aJ, 0)> = G && b> = D && (la =! 0, v ()))} função F () {função b () {if (! P) {u (! 1); s (y, função (a) {l.style [a [0]] = a [1]}); H (a, g); c.addClass (a, ba); if (p.recalculateTimingStyles) {T = l.getAttribute ( "class") + "" + V; ka = k.cacheKey (l, ja, g.addClass, g.removeClass); r = z (l, T, ka,! 1); ga = r.maxDelay; W =
Math.max (ga, 0); D = r.maxDuration; if (0 === D) {v (); return} p.hasTransitions = 0 <r.transitionDuration; p.hasAnimations = 0 <r.animationDuration} p.applyAnimationDelay && (ga = "booleano"! == tipo de g.delay &&a (g.delay)? parseFloat (g.delay): ga, W = Math.max (ga, 0), r.animationDelay = ga, ea = [qa, ga + "s"], y.push (ea), l.style [ea [0]] = ea [1]); G = 1E3 * W; R = 1E3 * D; if (g.easing) {var e, h = g.easing; p.hasTransitions && (e = M + "TimingFunction", y. push ([e, h]), l.style [e] = h); p.hasAnimations && (e = ca + " TimingFunction ", y.push ([e, h]), l.style [e] = h)} r.transitionDuration &&
w.push (Aa); r.animationDuration &&w.push (Ba); J = Date.now (); var m = G + 1.5 * R; e = J + m; var h = a.data ("$$ animateCss ") || [], F =! 0; if (h.length) {var n = h [0]; (F = e> n.expectedEndTime)? F.cancel (n.timer): h.push ( v)} F && (m = f (d, m,! 1), h [0] = {timer: m, esperadoEndTime: e}, h.push (v), a.data ("$$ animateCss", h ));; se (comprimento) a.on (w.join (""), q); g.to && (g.cleanupStyles && Ma (E, l, Object.keys (g.to)), Ja (a, g))}} função d () {var b = a.data ("$$ animateCss"); if (b) {for (var c = 1; c <comprimento b; c ++) b [c] () ; a.removeData ("$$ animateCss")}} if (! P) if (l.parentNode) {var e =
função (a) {if (la) m && a && (m =! 1, v ()); caso contrário, se (m =! a, r.animationDuration) if (a = xa (l, m), m) y.push ( a); else {var b = y, c = b.indexOf (a); 0 <= a && b.splice (c, 1)}}, h = 0 <aa && (r.transitionDuration && 0 === X.transitionDuration || r.animationDuration && 0 === X.animationDuration) && Math.max (X.animationDelay, X.transitionDelay); h? f (b, Math.floor (h * aa * 1E3) ,! 1): b (); A. resume = function () {e (! 0)}; A.pause = function () {e (! 1)}} else v ()} var g = b || {}; g. $$ preparado || ( g = pa (Da (g))); var E = {}, l = K (a); if (! l ||! l.parentNode ||! x.enabled ()) retorna h (); var y = [], O =
a.attr ("classe"), B = Qa (g), P, m, la, fa, A, W, G, D, R, J, w = []; if (0 === g.duração ||! Q.animations &&! Q.transitions) retornam h (); var ja = g.event && Z (g.event)? G.event.join (""): g.event, Y = ja &&g.estrutural, n = "", S = ""; Y? N = $ (ja, "ng -" ,! 0): ja && (n = ja); g.addClass && (S + = $ (g.addClass, "- adicionar")) ; g.removeClass && (S.length && (S + = ""), S + = $ (g.removeClass, "- remove")); g.applyClassesEarly && S.length && H (a, g); var V = [n, S]. junção (""). trim (), T = O + "" + V, O = B.to && 0 <Object.keys (B.to) .length; if (! (0 <(g.keyframeStyle || "") .length || O || V)) retorna h (); var X, ka =
k.cacheKey (l, ja, g.addClass, g.removeClass); if (k.containsCachedAnimationWithoutDuration (ka)) return V = null, h (); 0 <g.stagger? (B = parseFloat (g.stagger) , X = {transiçãoDelay: B, animaçãoDelay: B, transiçãoDuração: 0, animaçãoDuração: 0}): X = C (l, V, ka, Xa); g. $$ skipPreparationClasses || c.addClass (a, V) ; g.transitionStyle && (B = [M, g.transitionStyle], ma (l, B), y.push (B)); 0 <= g.duration && (B = 0 <l.style [M] .length, B = La (g.duração, B), ma (l, B), y.push (B)); g.keyframeStyle && (B = [ca, g.keyframeStyle], ma (l, B), y.push (B)); var aa = X? 0 <= g.staggerIndex?
g.staggerIndex: k.count (ka): 0; (n = 0 === aa) &&! g.skipBlocking && ra.blockTransitions (l, 9999); var r = z (l, T, ka,! Y), ga = r.maxDelay; W = Math.max (ga, 0); D = r.maxDuration; var p = {}; p.hasTransitions = 0 <r.transitionDuration; p.hasAnimations = 0 <r.animationDuration; p .hasTransitionAll = p.hasTransitions && "all" === r.transitionProperty; p.applyTransitionDuration = O && (p.hasTransitions &&! p.hasTransitionAll || p.hasAnimations &&! p.hasTransitions); p.applyTransitionDelay = ya (g.delay) && (p.applyTransitionDuration ||
p.hasTransitions); p.applyAnimationDelay = ya (g.delay) && p.hasAnimations; p.recalculateTimingStyles = 0 <S.length; if (p.applyTransitionDuration || p.applyAnimationDuration) D = g.duration? parseFloat (g. duration): D, p.applyTransitionDuration && (p.hasTransitions =! 0, r.transitionDuration = D, B = 0 <l.style [M + "Propriedade"]. length, y.push (La (D, B))) , p.applyAnimationDuration && (p.hasAnimations =! 0, r.animationDuration = D, y.push ([Ca, D + "s"])); if (0 === D &&! p.recalculateTimingStyles) return h (); var ba = $ (V, "- ativo"); if (null! = g.delay) {var ea;
"booleano"! == tipo de g.delay && (ea = parseFloat (g.delay), W = Math.max (ea, 0)); p.applyTransitionDelay && y.push ([na, ea + "s"]); p. applyAnimationDelay && y.push ([qa, ea + "s"])} null == g.duração && 0 <r.transitionDuration && (p.recalculateTimingStyles = p.recalculateTimingStyles || n); G = 1E3 * W; R = 1E3 * D; g .skipBlocking || (p.blockTransition = 0 <r.transitionDuration, p.blockKeyframeAnimation = 0 <r.animationDuration && 0 <X.animationDelay && 0 === X.animationDuration); g.from && (g.cleanupStyles && Ma (E, l, Object. chaves (g.from)), Ia (a, g)); p.blockTransition ||
p.blockKeyframeAnimation? u (D): g.skipBlocking || ra.blockTransitions (l,! 1); return {$$ willAnimate:! 0, end: e, start: function () {if (! P) return A = {fim: e, cancele: L, resumo: nulo, pausa: nulo}, fa = novo d (A), U (F), fa}}}}]}])). provider ("$$ animateCssDriver", ["$$ animationProvider", função (a) {a.drivers.push ("$$ animateCssDriver"); this. $ get = ["$ animateCss", "$ rootScope", "$$ AnimateRunner", "$ rootElement "," $ sniffer "," $$ jqLite "," $ document ", função (a, c, d, f, k, e, Q) {função L (a) {retorna a.replace (/ \ bng- \ S + \ b / g, "")} função x (a, b) {G (a) &&
(a = a.split ("")); G (b) && (b = b.split ("")); return a.filter (function (a) {return-1 === b.indexOf (a ))}). join ("")} função C (c, e, f) {função k (a) {var b = {}, c = K (a) .getBoundingClientRect (); s (["width", "height", "top", "left"], função (a) {var d = c [a]; switch (a) {case "top": d + = H.scrollTop; break; case "left": d + = H.scrollLeft} b [a] = Math.floor (d) + "px"}); retorna b} função v () {var c = L (f.attr ("classe") || ""), d = x (c, q), c = x (q, c), d = a (h, {para: k (f), addClass: "âncora-in") + d, removeClass: "ng-anchor -out "+ c, atraso:! 0}); retornar d. $$ willAnimate?
d: null} função C () {h.remove (); e.removeClass ("calibração de ng de animação"); f.removeClass ("calibração de ng de animação")} var h = A (K (e) .cloneNode (! 0)), q = L (h.attr ("classe") || ""); e.addClass ("ng-animate-shim"); f.addClass ("ng-animate-shim" ); h.addClass ("ng-anchor"); u.append (h); var F; c = function () {var c = a (h, {addClass: "ng-anchor-out", atraso :! 0, de: k (e)}); return c. $$ willAnimate? C: null} (); if (! C && (F = v () ,! F)) retorna C (); var g = c | | F; return {start: function () {function a () {c && c.end ()} var b, c = g.start (); c.done (function () {c = null; if (! F && ( F = v ())) retornar c =
Agora, você pode usar o seguinte método: () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () {end: a, cancel: a})}}} função z (a, b, c, e) {var f = oa (a, N), k = oa (b, N), h = []; s (e, função (a) {(a = C (c, a.out, a ["in"])) && h.push (a)}); if (f || k || 0! == h. comprimento) return {start: function () {function a () {s (b, function (a) {a.end ()})} var b = []; f && b.push (f.start ()); k && b .push (k.start ()); s (h, função (a) {b.push (a.start ())}); var c = new d ({end: a, cancel: a}); d .all (b, function (a) {c.complete (a)}); return c}}} function oa (c) {var d = c.element, e = c.options ||
{}; c.estrutural && (e.event = c.event, e.estrutural =! 0, e.applyClassesEarly =! 0, "leave" === c.event && (e.onDone = e.domOperation)); e .preparationClasses && (e.event = ba (e.event, e.preparationClasses)); c = a (d, e); return c. $$ willAnimate? c: null} if (! k.animations &&! k.transitions) return N; var H = Q [0] .body; c = K (f); var u = A (c.parentNode && 11 === c.parentNode.nodeType || H.contains (c)? c: H); função de retorno (a) {return a.from && a.to? z (a.from, a.to, a.classes, a.anchors): oa (a)}}]}]). provider ("$$ animateJs" , ["$ animateProvider", função (a) {this. $ get =
["$ injector", "$$ AnimateRunner", "$$ jqLite", função (b, c, d) {função f (c) {c = Z (c)? c: c.split (""); for (var d = [], f = {}, k = 0; k <comprimento.c; k ++) {var s = c [k], z = a. $$ RegisteredAnimations [s]; z &&! f [s ] && (d.push (b.get (z)), f [s] =! 0)} retorno d} var k = aa (d); função de retorno (a, b, d, x) {função C ( ) {x.domOperation (); k (a, x)} função z (a, b, d, f, e) {switch (d) {case "animate": b = [b, f.from, f. to, e]; break; case "setClass": b = [b, t, I, e]; break; case "addClass": b = [b, t, e]; break; case "removeClass": b = [b, I, e]; break; default: b = [b, e]} b.push (f); if (a = a.apply (a,
b)) if (Ea (a.start) && (a = a.start ()), uma instância de c) a.done (e); caso contrário, se (Ea (a)) retornar a; return N} função A ( a, b, d, e, f) {var h = []; s (e, função (e) {var l = e [f]; l && h.push (função () {var e, f, h =! 1, k = função (a) {h || (h =! 0, (f || N) (a), e.complete (! A))}; e = new c ({end: function () { k ()}, cancel: function () {k (! 0)}}); f = z (l, a, b, d, função (a) {k (! 1 === a)}); return e})}); return h} função H (a, b, d, e, f) {var h = A (a, b, d, e, f); if (0 === h.length) { var k, q; "beforeSetClass" === f? (k = A (a, "removeClass", d, e, "beforeRemoveClass"), q = A (a, "addClass", d, e, "beforeAddClass" )):
"setClass" === f && (k = A (a, "removeClass", d, e, "removeClass"), q = A (a, "addClass", d, e, "addClass")); k && (h = h.concat (k)); q && (h = h.concat (q))} if (0! == h.length) retorna a função (a) {var b = []; h.length && s (h, function (a) {b.push (a ())}); b.length? c.all (b, a): a (); função de retorno (a) {s (b, função (b) {a? b .cancel (): b.end ()})}}} var u =! 1; 3 === argumentos.length && ta (d) && (x = d, d = nulo); x = pa (x); d || (d = a.attr ("classe") || ", x.addClass && (d + =" "+ x.addClass), x.removeClass && (d + =" "+ x.removeClass)); var t = x.addClass, I = x.removeClass, G = f (d), K, v; if (G.length) {var M,
h; "deixar" === b? (h = "deixar", M = "afterLeave") :( h = "antes" + b.charAt (0) .toUpperCase () + b.substr (1), M = b); "enter"! == b && "move"! == b && (K = H (a, b, x, G, h)); v = H (a, b, x, G, M)} if (K || v) {var q; return {$$ willAnimate:! 0, end: function () {q? q.end () :( u =! 0, C (), ha (a, x) , q = new c, q.complete (! 0)); return q}, start: function () {function b (c) {u =! 0; C (); ha (a, x); q.complete (c)} if (q) retorna q; q = new c; var d, f = []; K && f.push (função (a) {d = K (a)}); f.length? f.push ( função (a) {C (); a (! 0)}): C (); v && f.push (função (a) {d = v (a)}); q.setHost ({end: function () { u || ((d ||
N) (void 0), b (void 0))}, cancele: function () {u || ((d || N) (! 0), b (! 0))}}); c.chain ( f, b); return q}}}}}]}]). provider ("$$ animateJsDriver", ["$$ animationProvider", função (a) {a.drivers.push ("$$ animateJsDriver"); $ get = ["$$ animateJs", "$$ AnimateRunner", função (a, c) {function d (c) {retorna a (c.element, c.event, c.classes, c.options) } função de retorno (a) {if (a.from && a.to) {var b = d (a.from), e = d (a.to); if (b || e) return {start: function () { função a () {função de retorno () {s (d, função (a) {a.end ()})}} var d = []; b && d.push (b.start ()); e &&
() () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () (()) ); return f}}} else return d (a)}}]}])}) (window, window.angular);
// # sourceMappingURL = angular-animate.min.js.map