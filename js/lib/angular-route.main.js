/*
 AngularJS v1.7.8
 (c) 2010-2018 Google, Inc. http://angularjs.org
 Licença: MIT
*/
(function (I, b) {'use strict'; function z (b, h) {var d = [], c = b.replace (/([()))) / g, "\\ $ 1") .replace (/ (\ /)?: (\ w +) (\ * \? | [? *])? / g, função (b, c, h, k) {b = "?" === k | | "*?" === k; k = "*" === k || "*?" === k; d.push ({nome: h, opcional: b}); c = c || ""; return (b? "(?:" + c: c + "(?:") + (k? "(. +?)": "([^ /] +)") + (b? "? )? ":") ")}). replace (/ ([/ $ *]) / g," \\ $ 1 "); h.ignoreTrailingSlashes && (c = c.replace (/ \ / + $ /," " ) + "/ *"); return {keys: d, regexp: new RegExp ("^" + c + "(?: [? #] | $)", h.caseInsensitiveMatch? "i": "")}} função A (b) {p && b.get ("$ route")} função v (u, h, d) {return {strict: "ECA",
terminal:! 0, prioridade: 400, transclude: "elemento", link: function (c, f, g, l, k) {function q () {r && (d.cancel (r), r = null); m && (m. $ destroy (), m = nulo); s && (r = d.deixar (s), r.done (função (b) {! 1! == b && (r = null)}), s = nulo )} função C () {var g = u.current && u.current.locals; if (b.isDefined (g && g. $ template)) {var g = c. $ new (), l = u.current; s = k (g, função (g) {d.enter (g, nulo, s || f). concluído (função (d) {! 1 === d ||! b.isDefined (w) || w &&! c. $ eval (w) || h ()}); q ()}); m = l.scope = g; m. $ emit ("$ viewContentLoaded"); m. $ eval (p)} else q () } var m, s, r, w = g.autoscroll, p = g.onload ||
""; c. $ on ("$ routeChangeSuccess", C); C ()}}} função x (b, h, d) {retornar {restringir: "ECA", prioridade: -400, link: function (c , f) {var g = d.current, l = g.locals; f.html (l. $ template); var k = b (f.contents ()); if (g.controller) {l. $ scope = C; var q = h (g.controller, l); g.controllerAs && (C [g.controllerAs] = q); f.data ( "$ ngControllerController", q);. (f.children) de dados (" $ ngControllerController", Q)} c [g.resolveAs || "$ resolver"] = l; k (c)}}} var D, E, F, G, y = b.module ( "ngRoute", [] ) .info ({angularVersion: "1.7.8"}). provider ("$ route", function () {function u (d,
c) {return b.extend (Object.create (d), c)} D = b.isArray; E = b.isObject; F = b.isDefined; G = b.noop; var h = {}; isso. quando = função (d, c) {var f; f = vazio 0; se (D (c)) {f = f || []; para (var g = 0, l = comprimento c; g <l; g ++) f [g] = c [g]} senão se (E (c)) para (g em f = f || {}, c) if ("$"! == g.charAt (0) || ! "$" == g.charAt (1)) f [g] = c [g]; f = f || c; b.isUndefined (f.reloadOnUrl) && (f.reloadOnUrl = 0);! b. isUndefined (f.reloadOnSearch) && (f.reloadOnSearch =! 0); b.isUndefined (f.caseInsensitiveMatch) && (f.caseInsensitiveMatch = this.caseInsensitiveMatch); h [d] = b.extend (f, {originalPath: d }
d && z (d, f)); d && (g = "/" === d [d.length-1]? d.substr (0, d.length-1): d + "/", h [g] = b.extend ({caminho original: d, redirecionar para: d}, z (g, f))); retornar isso}; this.caseInsensitiveMatch =! 1; this.otherwise = function (b) {"string" === typeof b && (b = {redirectTo: b}); this.when (null, b); return this}; p =! 0; this.eagerInstantiationEnabled = function (b) {return F (b)? (p = b, isto ): p}; this. $ get = ["$ rootScope", "$ location", "$ routeParams", "$ q", "$ injector", "$ templateRequest", "$ sce", "$ browser" , função (d, c, f, g, l, k, q, p) {função m (a) {var e = corrente atual; n = A (); (x =
! B && n && e && n. $$ route === e. $$ route && (! N.reloadOnUrl ||! N.reloadOnSearch && b.equals (n.pathParams, e.pathParams))) ||! E &&! N || d. $ Broadcast ("$ routeChangeStart", n, e) .defaultPrevented && a && a.preventDefault ()} função s () {var a = corrente atual, e = n; se (x) a.params = e.params, b.copy (a .params, f), d. $ broadcast ("$ routeUpdate", a); caso contrário, se (e || a) {B =! 1; t.current = e; var c = g.resolve (e); p . $$ incOutstandingRequestCount ("$ route"); c.then (r) .then (w) .then (function (g) {return g &&c.then (y) .then (function (c) {e === t .current && (e && (e.locals = c, b.copy (e.params,
f)), d. $ broadcast ("$ routeChangeSuccess", e, a))})}). catch (função (b) {e === t.current && d. $ broadcast ("$ routeChangeError", e, a , finalmente, function () (p. $$ completeOutstandingRequest (G, "$ route")})}} function r (a) {var e = {route: a, hasRedirection:! 1}; if (a) if (a.redirectTo) if (b.isString (a.redirectTo)) e.path = v (a.redirectTo, a.params), e.search = a.params, e.hasRedirection =! 0; Em caso de dúvida, entre em contato com a Central de Atendimento ao Cliente (SAC), pelo telefone (11) 3221-8000. hasRedirection =! 0)} else if (a.resolveRedirectTo) retorna g.resolve (l.invoke (a.resolveRedirectTo)). then (function (a) {b.isDefined (a) &&
(e.url = a, e.hasRedirection =! 0); return e}); return e} function w (a) {var b =! 0; if (a.route! == t.current) b =! 1; else if (a.hasRedirection) {var g = c.url (), d = a.url; d? C.url (d) .replace (): d = c.path (a.path) .search (a.search) .replace (). url (); d! == g && (b =! 1)} retornar b} função y (a) {if (a) {var e = b.extend ({}, a.resolve); b.forEach (e, function (a, c) {e [c] = b.isString (a)? l.get (a): l.invoke (a, null, null, c)} ); a = z (a); b.isDefined (a) && (e. $ template = a); return g.all (e)}} função z (a) {var e, c; b.isDefined (e = a.template)? b.isFunction (e) && (e = e (a.params)):
b.isDefined (c = a.templateUrl) && (b.isFunction (c) && (c = c (a.params)), b.isDefined (c) && (a.loadedTemplateUrl = q.valueOf (c), e = k (c))); retorna e} função A () {var a, e; b.forEach (h, função (d, g) {var f; se (f =! e) {var h = c. path (); f = d.keys; var l = {}; if (d.regexp) if (h = d.regexp.exec (h)) {for (var k = 1, p = h.length; k <p; ++ k) {var m = f [k-1], n = h [k]; m && n && (l [m.name] = n)} f = l} else f = null; else f = null ; f = a = f} f && (e = u (d, {params: b.extend ({}, c.search (), a), pathParams: a}), e. $$ route = d)}) ; return e || h [nulo] && u (h [nulo], {params: {}, pathParams: {}})} função v (a,
c) {var d = []; b.forEach ((a || ""). split (":"), função (a, b) {if (0 === b) d.push (a); else {var f = a.match (/ (\ w +) (?: [? *])? (. *) /), g = f [1]; d.push (c [g]); d.push (f [2] || ""); delete c [g]}}); retorne d.join ("")} var B =! 1, n, x, t = {rotas: h, recarregar: função ( ) {B =! 0; var a = {defaultPrevented:! 1, preventDefault: function () {this.defaultPrevented =! 0; B =! 1}}; d. $ EvalAsync (function () {m (a); a.defaultPrevented || s ()})}, updateParams:. função de (a) {if (this.current && this.current $$ rota) a = b.extend ({}, this.current.params, a), c .path (v (this.current. $$ route.originalPath,
a), c.search (a); else throw H ("norout");}}; d. $ on ("$ locationChangeStart", m); d. $ on ("$ locationChangeSuccess", s); return t}]}). run (A), H = b. $$ minErr ("ngRoute"), p; A. $ inject = ["$ injector"]; y.provider ("$ routeParams", function () {this. $ get = function () {return {}}}); y.directive ("ngView", v); y.directive ("ngView", x); v. $ inject = ["$ route", "$ anchorScroll", "$ animate"]; x. $ inject = ["$ compile", "$ controller", "$ route"]}) (window, window.angular);
// # sourceMappingURL = angular-route.min.js.map